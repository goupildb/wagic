#!/usr/bin/perl 
###########################################
#
# this script will parse the db generated by Gatherer Extractor to build a
#	file with Wagic card definitions partially filled in.
############################################
my %rarityMap = ( 
			"Uncommon" => "U", 
			"Common" => "C",
			"Rare" 	=> "R",
			"Mythic" => "M"
		);

my %costNumberMap = (	
			"a" => 1,
			"an" => 1,
			"one" => 1,
			"two" => 2,
			"three" => 3,
			"four" => 4
		);

my %extraCosts = ();
my $cardCost;
while (<>)
{
	chomp;
	s///g;
	s/Text=/text=/;

	if (/\[\/card/ )
	{
		foreach $extraCost (keys %extraCosts)
		{
			my $cost = $extraCost eq "Multikicker" ? "multi" : "";
			print lc ($extraCost) . "=$cost" . subCosts($extraCosts{$extraCost}) . "\n";
			delete $extraCosts{$extraCost};
		}
		print "[/card]\n";
	}
	elsif (/^Name=(.*)/)
	{
		print "name=$1\n";
	}
	elsif (/Mana=/)
	{
		s/Mana=//;
		s/(\w)/\{$1}/g;
		s/\((\{.*?\})\)/$1/g;
		s/\}\/\{/\//g;
		print "mana=$_\n";
		$cardCost = $_;
	}

	elsif (/^Type=/ )
	{
		my ($type, $subtype) = split /\s*\x97\s*/, $';
		print "type=$type\n";
		print "subtype=$subtype\n" if ($subtype);
	}
	elsif (/^Power/)
	{
		s/Power.*?=//gi;
		s/[\(\)]//g;
		my ($power, $toughness) = split /\//;	
		print "power=$power\n" if ($power);
		print "toughness=$toughness\n" if ($toughness);
	}
	elsif (/Rarity=/)
	{
		my @setsInfo = split /,/, $';
		my @sets, @rarity;
		foreach my $setInfo (@setsInfo)
		{
			my ($set, $rarity);
			if ($setInfo  =~ /(.*?)(Rare|Common|Uncommon|Mythic)/i)
			{
				$set = $1;
				$rarity = $rarityMap{$2};
			}
		}	
	}
	elsif ( /(Multikicker|Kicker|Buyback|Flashback)\s*\x97?\s*(.*?)\(You may/)
	{
		print "$_\n";
		$extraCosts{$1} = $2;
		#print STDERR "** $1=$2\n";	
	}
	elsif ( /(Kicker|Flashback|Buyback).*?(\{[\}\{GUBWRP\d].*?)\(/ )
	{
		print "$_\n";
		$extraCosts{$1} = $2;
		#print STDERR "+ $1=$2\n";	
	}
	elsif ( /^(Retrace)/ )
	{
		$extraCosts{$1} = $cardCost;
		s/Text=/text=/;
		print "$_\n";
	}
	elsif ( /Text=/ )
	{
		print "text=$'\n";
	}
	else
	{
		print "$_\n";
	}

}


sub subCosts
{
	my $cost = shift (@_);
	my $discardText = '{discard(*|myhand)}';
	my $sacIslandText = '{S(island|mybattlefield)}';
	my $sacLandText = '{S(land|mybattlefield)}';
	my $sacCreatureText = '{S(creature|mybattlefield)}';
	my $tapText = '{S(creature|mybattlefield)}';
	$cost =~ s/Pay (\d+) life/'{L}' x $1/ei;
	$cost =~ s/Discard (a|one|two|three) cards? at random.*/{D}{$costNumberMap{$1}}/ei;
	$cost =~ s/Discard (one|two|three) cards?.*/$discardText x $costNumberMap{$1}/ei;
	$cost =~ s/Sacrifice (one|two|three) islands/$sacIslandText x $costNumberMap{$1}/ei;
	$cost =~ s/Sacrifice (a|one|two|three) lands.*/$sacLandText x $costNumberMap{$1}/ei;
	$cost =~ s/Sacrifice (a|one|two|three) creature.*/$sacCreatureText x $costNumberMap{$1}/ei;
	$cost =~ s/Tap (an|one|two|three) untapped (.*?) you control.*/"{T($2|mybattlefield)}" x $costNumberMap{$1}/ei;
	$cost =~ s/Return (a|one|two|three) creature(.*?) .*/"{H(creature|mybattlefield)}" x $costNumberMap{$1}/ei;

	return $cost;	
}
